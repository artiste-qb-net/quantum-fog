#include "QB_NET.h"#include "C_DOC.h"#include "EXCEPTIONS.h"#include "MY_FSTREAMS.h"#include <ctype.h>#include "BEAM_SPL.h"#include "CUSTOM_ND.h"#include "DET_ND.h"#include "POL_ROTATOR.h"#include "POLARIZER.h"#include "QBIT_ROT.h"#include "SG_MAGNET.h"// template is defined, but not matching these: links but doesn't compile.// so I defined them explicitly here as free functions. //dpo/*LStream  &		operator<<(LStream  &				out_bd,		//i-oconst VECTOR<USHORT>  &	v)			//in{	out_bd << v.its_len;	for(USHORT	i=0; i<v.its_len; i++){		out_bd << v[i];	}	return out_bd;}//******************************************LStream  &		operator>>(LStream  &			in_bd,			//i-oVECTOR<USHORT>  &		v)			//in { 	USHORT 	len;	in_bd >> len;	USHORT	x;	v.resize(x, len); 	for(USHORT	i=0; i<len; i++){		in_bd >> v[i];	}	return in_bd;}*///rrt: template problem fixed following advice from newsgroup post by Dave Meyer#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.	#include "C_MAIN_VIEW.h"#endif //_mac_gui_app \\............................................//#pragma mark ---------used only with macgui--------#ifdef   _mac_gui_app //''''''''''''''''''''''''''''''''''''''''''''\\.#pragma mark --creation/destruction--//******************************************VOID	QB_NET::set_doc_and_mview_ptrs(C_DOC  *  		doc_p,		//inC_MAIN_VIEW  *  view_p)		//in{	//used only by C_DOC, in its constructor	its_doc_p = doc_p;	its_mview_p = view_p;}#pragma mark --reorder nodes, parent_nds, nd_sts--//******************************************VOID	QB_NET::reorder_nds(const UI_MAP  &		map)		//in{	its_mview_p->set_is_modified(true, mview_del);	if(its_num_of_nds==0)return;	SignalIf_(map.its_oldfn.get_len()!=its_num_of_nds);	SignalIf_(map.its_newfo.get_len()!=its_num_of_nds);	if(map.is_identity_map())return;			USHORT	i;	NODE  *  *	old_nds_p_p = new NODE  * [its_num_of_nds];//new[]	//delete: in this method	ThrowIfNil_(old_nds_p_p);	for(i=0; i<its_num_of_nds; i++){		old_nds_p_p[i] = its_nds_p_p[i];	}	for(i=0; i<its_num_of_nds; i++){		its_nds_p_p[i] = old_nds_p_p[map.its_oldfn[i]];	}	delete []	old_nds_p_p;	old_nds_p_p=0;	for(i=0; i<its_num_of_nds; i++){		its_nds_p_p[i]->renumber_in_nds(map);		its_nds_p_p[i]->renumber_out_nds(map);		its_nds_p_p[i]->get_efield_ptr()->set_nd_always(i);		its_nds_p_p[i]->renumber_nds_of_port_glists(map);	}		//there shouldn't be any node name dictionary around	ThrowIf_(its_nd_name_dict_p!=0);			DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		dir_bi_nd_p->its_data.renumber_nds(map);		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}	for(USHORT	time=0; time<its_num_of_nds; time++){		its_nd_chronology[time] = map.its_newfo[its_nd_chronology[time]];	}		DIR_DATA<C_ARROW>  *  dir_arrow_p = its_arrows.get_first_p();	while(dir_arrow_p){		dir_arrow_p->its_data.renumber_nds(map);		dir_arrow_p = dir_arrow_p->its_next_p;	}}//******************************************VOID	QB_NET::reorder_nd_sts(USHORT		nd_id,			//inconst UI_MAP  &		map)	//in{	its_mview_p->set_is_modified(true, mview_del);	NODE  *		nd_p = its_nds_p_p[nd_id];	nd_p->reorder_sts(map);	VECTOR<USHORT>  out_nds = nd_p->get_out_nds();	for(USHORT	i=0; i<out_nds.get_len(); i++){		its_nds_p_p[out_nds[i]]->change_tm_as_part_of_reordering_nd_sts_of_a_pa(nd_id, map);	}}#pragma mark --delete nodes and arrows--//******************************************VOID	QB_NET::del_int_arrow(USHORT 		s,				//inUSHORT 		d,				//inBOOLEAN		try_to_sort)	//in{	its_mview_p->set_is_modified(true, mview_del);	// del = delete, s = source, d= destination	//there are no delete methods (del arrow, nd or bi-nd) in the ansi program	// int = internal	its_nds_p_p[s]->del_out_nd(d);	its_nds_p_p[d]->del_in_nd(s);	its_nds_p_p[s]->remove_nd_from_all_port_glists(d);	its_nds_p_p[d]->remove_nd_from_all_port_glists(s);	C_ARROW  *  ar_p; 	DIR_DATA<C_ARROW>  *  dir_arrow_p = its_arrows.get_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		if(  (ar_p->get_s_port_name().its_nd_id==s)&&(ar_p->get_d_port_name().its_nd_id==d) ){			ar_p->undraw(); 			//Erase handles, if present. Also decrement num of sel arrows.			ar_p->unselect(its_mview_p);			its_arrows.extract_target(dir_arrow_p);// delete arrow's record and set dir_arrow_p=0 			goto  stop_looking;		}		dir_arrow_p = dir_arrow_p->its_next_p;	}	stop_looking:;	if(try_to_sort)chrono_sort();}//******************************************VOID	QB_NET::del_nd(USHORT 	nd_id,				//inBOOLEAN try_to_sort)		//in{	its_mview_p->set_is_modified(true, mview_del);		//reorder if selected node is not in last position	if(nd_id != its_num_of_nds -1){		UI_MAP  	map(its_num_of_nds); //map is identity map immediately after creation		map.its_newfo[nd_id] = its_num_of_nds - 1;		for(USHORT i=nd_id+1; i<its_num_of_nds; i++){			map.its_newfo[i] = i-1;		}		map.set_oldfn();		reorder_nds(map);	}	NODE  *  nd_p = its_nds_p_p[its_num_of_nds-1];	USHORT i;	//Must calculate this outside of for() statement	//because it will change each time we loop.	USHORT  in_nds_len = nd_p->get_in_nds().get_len(); 			for(i= 0; i<in_nds_len; i++){		del_int_arrow(nd_p->get_in_nds()[0], its_num_of_nds-1, false);	}	//Must calculate this outside of for() statement	//because it will change each time we loop.	USHORT  out_nds_len = nd_p->get_out_nds().get_len(); 			for(i = 0; i < out_nds_len; i++){		del_int_arrow(its_num_of_nds-1, nd_p->get_out_nds()[0], false);	}			nd_p->undraw();	//Erase handles, if present. Also decrement num of sel nds.	nd_p->unselect(its_mview_p);//%%%%%%%%%%%%%%%%%%%%%	//due to LEditField bug, must create and destroy nd and nd_efield separately	its_mview_p->destroy_nd_efield(its_num_of_nds-1);	delete  nd_p;	nd_p = 0;//%%%%%%%%%%%%%%%%%%%%%	del_all_bi_nds_with_this_nd(its_num_of_nds-1);	its_nds_p_p[its_num_of_nds-1]=0;	--its_num_of_nds;	if(try_to_sort){		chrono_sort();		its_dyn_story.set_to_default_vec(0, its_num_of_nds);	}		}//******************************************VOID	QB_NET::del_bi_nd(USHORT xed_position)		//in{	USHORT  pos=0;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p){		if(pos==xed_position){			//this deletes  memory pointed to by dir_bi_nd_p and sets dir_bi_nd_p=0:			its_bi_nds.extract_target(dir_bi_nd_p);			return;		}		pos++;		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}	}//******************************************VOID	QB_NET::del_all_bi_nds_with_this_nd(USHORT	nd_id)		//in{	BI_NODE  *  bi_nd_p;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p;	begin_list: ; 	dir_bi_nd_p= its_bi_nds.get_first_p();	while(dir_bi_nd_p){		bi_nd_p = &(dir_bi_nd_p->its_data);		if(bi_nd_p->has(nd_id)){			//this deletes  memory pointed to by dir_bi_nd_p and sets dir_bi_nd_p=0:			its_bi_nds.extract_target(dir_bi_nd_p);			goto begin_list; 		}		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}	}#pragma mark --add nodes and arrows--//******************************************BOOLEAN		QB_NET::calc_closest_pts(const C_CIRCLE  &  cir1,		//inconst C_CIRCLE  &  cir2, 		//inPoint  &  	pt1,				//outPoint  &  	pt2) 				//out{// pt1 and pt2  are elements of  // the circles cir1 and cir2, respectively.// These points are the unique endpoints of the shortest segment // between the two circles. // This function returns false iff the 2 circles intersect. 	Point  cen1 = cir1.its_center;	SInt16  r1 = cir1.its_radius;	Point  cen2 = cir2.its_center;	SInt16  r2 = cir2.its_radius;	DOUBLE dist = sqrt( pow(DOUBLE(cen1.h-cen2.h), 2) + pow(DOUBLE(cen1.v-cen2.v), 2) );	if(	dist<=DOUBLE(r1+r2))return false;	DOUBLE ss= DOUBLE( cen2.v - cen1.v)/dist;	DOUBLE cc= DOUBLE( cen2.h - cen1.h)/dist; 		pt1.h = nearest_int16(cen1.h + r1*cc);	pt1.v = nearest_int16(cen1.v + r1*ss);	pt2.h = nearest_int16(cen2.h - r2*cc);	pt2.v = nearest_int16(cen2.v - r2*ss);	return true;}//******************************************C_ARROW  *	 QB_NET::mac_add_int_arrow(const C_PORT_NAME  &  s_port_name,		//inconst C_PORT_NAME  &  d_port_name,		//inBOOLEAN try_to_sort) 					//in{	its_mview_p->set_is_modified(true, mview_del);		NODE  *  s_nd_p = its_nds_p_p[s_port_name.its_nd_id];	NODE  *  d_nd_p = its_nds_p_p[d_port_name.its_nd_id];	// check that the source and destination nodes aren't the same	if( s_nd_p == d_nd_p ) return 0;	// check that this arrow hasn't been added before	if(		( s_nd_p->get_out_nds().loc_of_target(d_port_name.its_nd_id) != max_ushort )		||		( d_nd_p->get_in_nds().loc_of_target(s_port_name.its_nd_id) != max_ushort )	) return 0;	C_CIRCLE  	s_cir = s_nd_p->get_docking_cir(s_port_name.its_sub_nd_id);	C_CIRCLE  	d_cir = d_nd_p->get_docking_cir(d_port_name.its_sub_nd_id);	Point  init_pt, fin_pt;	// check that nodes don't intersect	if(!calc_closest_pts(s_cir, d_cir, init_pt, fin_pt))return 0;	C_ARROW   ar((LView  *)its_mview_p, s_port_name, d_port_name, init_pt, fin_pt);	ar.draw();	its_arrows.insert_first(ar);	s_nd_p->add_out_nd(d_port_name.its_nd_id);	d_nd_p->add_in_nd(s_port_name.its_nd_id, s_nd_p->get_degen());	s_nd_p->add_nd_to_port_glist(d_port_name.its_nd_id, s_port_name.its_sub_nd_id);	d_nd_p->add_nd_to_port_glist(s_port_name.its_nd_id, d_port_name.its_sub_nd_id);	if(try_to_sort){		if(!chrono_sort() ){ 			del_int_arrow(s_port_name.its_nd_id, d_port_name.its_nd_id, false);			warn_user_about_cycle();			return 0;		}	}	return &(its_arrows.get_first_p()->its_data);	}//******************************************USHORT		QB_NET::mac_add_nd(ND_CLASS_ID 	nd_class_id,		//inconst Point  &  	m_down_pt,		//inBOOLEAN 	try_to_sort)			//in{	its_mview_p->set_is_modified(true, mview_del);	if( its_num_of_nds == its_num_of_nd_ptrs )   grow_num_of_nd_ptrs();	its_num_of_nds++;		NODE  * 	nd_p=0; //%%%%%%%%%%%%%%%%%%%%%	//due to LEditField bug, must create and destroy nd and nd_efield separately	switch(nd_class_id){		case BEAM_SPL_id:			nd_p = new BEAM_SPL( m_down_pt);			//delete: by class destructor. See also QB_NET::clear_nds() and QB_NET::del_nd()			break;		case CUSTOM_ND_id:			nd_p = new CUSTOM_ND( m_down_pt);			//delete: by class destructor			break;				case DET_ND_id:			nd_p = new DET_ND( m_down_pt);			//delete: by class destructor. 			break;		case POL_ROTATOR_id:			nd_p = new POL_ROTATOR( m_down_pt);			//delete: by class destructor			break;		case POLARIZER_id:			nd_p = new POLARIZER( m_down_pt);			//delete: by class destructor			break;		case QBIT_ROT_id:			nd_p = new QBIT_ROT(m_down_pt);			//delete: by class destructor			break;		case SG_MAGNET_id:			nd_p = new SG_MAGNET( m_down_pt);			//delete: by class destructor			break;	}	ThrowIfNil_(nd_p);	its_nds_p_p[its_num_of_nds-1] = nd_p;	its_mview_p->create_nd_efield(m_down_pt, its_num_of_nds -1); //%%%%%%%%%%%%%%%%%%%%%	nd_p->draw();	if(try_to_sort){		chrono_sort();		its_dyn_story.set_to_default_vec(0, its_num_of_nds);	}		return its_num_of_nds-1; // the returned number will become the node id.}#pragma mark --change arrow s source--//******************************************BOOLEAN	 QB_NET::nodes_have_same_state_set(USHORT		nd1,		//inUSHORT		nd2)		//in{	NODE  * 	nd1_p = its_nds_p_p[nd1];	NODE  * 	nd2_p = its_nds_p_p[nd2];	USHORT degen1 = nd1_p->get_degen();	USHORT degen2 = nd2_p->get_degen();		if(degen1!=degen2)return false;	for(USHORT	i=0; i< degen1; i++){		if(nd1_p->get_st_name(i)!=nd2_p->get_st_name(i))return false;		}	return true;	}//******************************************BOOLEAN	 QB_NET::change_source_nd_of_ar(C_ARROW  *  	ar_p,						//inconst C_PORT_NAME  &  new_s_port_name)		//in{	//this function is similar to QB_NET::mac_add_int_arrow()		its_mview_p->set_is_modified(true, mview_del);	NODE  *  	new_s_nd_p = its_nds_p_p[new_s_port_name.its_nd_id];		C_PORT_NAME	old_s_port_name = ar_p->get_s_port_name();	NODE  *  	old_s_nd_p = its_nds_p_p[old_s_port_name.its_nd_id];		C_PORT_NAME	d_port_name = ar_p->get_d_port_name();	NODE  *  	d_nd_p = its_nds_p_p[d_port_name.its_nd_id];	// check that the source and destination nodes aren't the same	if( new_s_nd_p == d_nd_p ) return false;	// check that this arrow hasn't been added before	if(		( new_s_nd_p->get_out_nds().loc_of_target(d_port_name.its_nd_id) != max_ushort )		||		( d_nd_p->get_in_nds().loc_of_target(new_s_port_name.its_nd_id) != max_ushort )	) return false;	//check that the two s nodes have the same state set		if(!nodes_have_same_state_set(new_s_port_name.its_nd_id, old_s_port_name.its_nd_id)){		my_gen_alert("New source node is incompatible with old one. To change an arrow's source node from node A to node B, A and B must have the same number of states, the states must have the same names, and the names must be listed in the same order."); 		return false;	}	C_CIRCLE  	s_cir =new_s_nd_p->get_docking_cir(new_s_port_name.its_sub_nd_id);	C_CIRCLE  	d_cir =d_nd_p->get_docking_cir(d_port_name.its_sub_nd_id);	Point  init_pt, fin_pt;		// check that nodes don't intersect	if(!calc_closest_pts(s_cir, d_cir, init_pt, fin_pt))return false;	new_s_nd_p->add_out_nd(d_port_name.its_nd_id);	old_s_nd_p->del_out_nd(d_port_name.its_nd_id);	d_nd_p->change_in_nd_to_compatible_one(old_s_port_name.its_nd_id, new_s_port_name.its_nd_id);	if(!chrono_sort() ){ 		new_s_nd_p->del_out_nd(d_port_name.its_nd_id);		old_s_nd_p->add_out_nd(d_port_name.its_nd_id);		d_nd_p->change_in_nd_to_compatible_one(new_s_port_name.its_nd_id, old_s_port_name.its_nd_id);		warn_user_about_cycle();		return false;	}	ar_p->change_source_nd(new_s_port_name, init_pt, fin_pt);	old_s_nd_p->remove_nd_from_all_port_glists(d_port_name.its_nd_id);	d_nd_p->remove_nd_from_all_port_glists(old_s_port_name.its_nd_id);	new_s_nd_p->add_nd_to_port_glist(d_port_name.its_nd_id, new_s_port_name.its_sub_nd_id);	d_nd_p->add_nd_to_port_glist(new_s_port_name.its_nd_id, d_port_name.its_sub_nd_id);		return true;}#pragma mark --write/read net--//******************************************VOID	QB_NET::write_net_stream(LStream  &  	net_stream,		//i-o	NET_STREAM_TYPE		stream_type)		//in{	USHORT	i;	USHORT	num_of_sel_nds = its_mview_p->get_num_of_sel_nds();	USHORT	num_of_unsel_nds = its_num_of_nds - num_of_sel_nds;		/*	if(stream_type==open_reco){		net_stream<<its_num_of_nds;	}else{// stream_type==undel_reco||stream_type==paste_reco		net_stream<<num_of_sel_nds;	}*/	net_stream<<(stream_type==open_reco?its_num_of_nds:num_of_sel_nds);//write_net	if(stream_type==paste_reco){		net_stream<<its_mview_p->get_sel_rect();//write_net	}	RGBColor 		color;	Point 			center;	STRINGY  		nd_class_str;	UInt16			UInt16_nd_class_id;	STRINGY   		nd_name;	NODE  * 		nd_p;			BOOLEAN 		store;	for(i=0; i<its_num_of_nds;i++){		nd_p = its_nds_p_p[i];		store = true;		if(stream_type!=open_reco){			store = nd_p->is_selected();		}		if(store){					nd_class_str = get_nd_class_str(i);			UInt16_nd_class_id = (UInt16)get_nd_class_id(i);						center = nd_p->get_center();			nd_name = nd_p->get_name();						if(its_doc_p->get_vers_int32()<= k_vers_160){				net_stream<<nd_class_str<<center<<nd_name;//write_net			}else{				net_stream<<UInt16_nd_class_id<<center<<nd_name;//write_net			}						if(nd_p->has_color()){				color = nd_p->get_color();						net_stream<<color.red<<color.green<<color.blue;//write_net			}			if(nd_p->has_icon_dir()){				net_stream<<nd_p->get_icon_dir();//write_net			}		}	}	USHORT	num_of_arrows = its_arrows.get_len();	USHORT	num_of_stored_arrows = 0;	VECTOR<USHORT> 	store_arrow(1, num_of_arrows);//0=don't store it, 1=do store it	USHORT	ar_counter = 0;		if(stream_type!=open_reco){			C_ARROW  *  ar_p;			DIR_DATA<C_ARROW>  *  dir_arrow_p = get_arrows_first_p();		while(dir_arrow_p){			ar_p = &(dir_arrow_p->its_data);			if(stream_type==undel_reco){				if(its_mview_p->s_or_d_or_ar_selected(ar_p)){					//store_arrow[ar_counter] = 1 by default					num_of_stored_arrows++;				}else{					store_arrow[ar_counter] = 0;				}								}			if(stream_type==paste_reco){				if(its_mview_p->s_and_d_and_ar_selected(ar_p)){					//store_arrow[ar_counter] = 1 by default					num_of_stored_arrows++;				}else{					store_arrow[ar_counter] = 0;				}			}			dir_arrow_p = dir_arrow_p->its_next_p;			ar_counter++;		}	}	net_stream<<(stream_type==open_reco?num_of_arrows:num_of_stored_arrows);//write_net		C_PORT_NAME	s_port_name, d_port_name;	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = get_arrows_first_p();	ar_counter = 0;	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		s_port_name = ar_p->get_s_port_name();		d_port_name = ar_p->get_d_port_name();		if(store_arrow[ar_counter]){			if(stream_type==paste_reco){				s_port_name.its_nd_id -= num_of_unsel_nds;							d_port_name.its_nd_id -= num_of_unsel_nds;			}			net_stream<< s_port_name;//write_net			net_stream<< d_port_name;//write_net		}		dir_arrow_p = dir_arrow_p->its_next_p;		ar_counter++;	}		//In the case of undel_reco and delete, C_MAIN_VIEW::delete_selection() calls	//QB_NET::del_nd(), which calls QB_NET::del_all_bi_nds_with_this_nd()			if(stream_type==open_reco){		net_stream<<its_bi_nds.get_len();//write_net		BI_NODE  *  bi_nd_p;		DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();		while(dir_bi_nd_p){			bi_nd_p = &(dir_bi_nd_p->its_data);			net_stream<<bi_nd_p->get_nd1()<<bi_nd_p->get_nd2();//write_net			dir_bi_nd_p = dir_bi_nd_p->its_next_p;		}	}		for(i=0; i<its_num_of_nds;i++){		nd_p = its_nds_p_p[i];		store = true;		if(stream_type!=open_reco){			store = nd_p->is_selected();		}		if(store){			net_stream << nd_p->get_degen() << nd_p->get_active_states();//write_net;			for(USHORT r=0; r<nd_p->get_degen(); r++){				net_stream << nd_p->get_st_name(r);//write_net			}		}	}	USHORT 		max_n_sum;	SHORT 		spin;	DOUBLE64	theta, phi, tau_mag, tau_ang, rho_ang;//store machine indep doubles	BOOLEAN 	empty, store_the_store_flag;	VECTOR<USHORT> in_nds;	USHORT	len;	for(i=0; i<its_num_of_nds;i++){		nd_p = its_nds_p_p[i];		//store the trans mat and related params?		switch(stream_type){			case open_reco:				//Store tm for all nodes:				store = true;				//Don't need to store the store flag since tm for all nodes is saved.				store_the_store_flag = false;				break;			case undel_reco:				//Store tm for superset of selected nodes:				store = its_mview_p->undeleting_should_restore_amps_of(i);				//Store the store flag for all nodes,				//since may need to remember tm for some unselected nodes. 				store_the_store_flag = true;				break;			case paste_reco:				//Store tm for subset of selected nodes:				store = its_mview_p->pasting_should_restore_amps_of(i);				//Store the store flag only for selected nodes,				//since need to remember tm for subset of selected nodes. 				store_the_store_flag = nd_p->is_selected();				break;		}				if(store_the_store_flag) net_stream<<store;//write_net		if(store){			in_nds = nd_p->get_in_nds();			if(stream_type==paste_reco){				len = in_nds.get_len();				for(USHORT j =0; j<len; j++){					in_nds[j] -= num_of_unsel_nds;					SignalIf_(in_nds[j]<0);				}			}			//Does not appear in vers. 1.0§2 or earlier:			net_stream<<in_nds;//write_net											//this writes the trans mat			nd_p->write_net_stream(net_stream);//write_net			if(its_doc_p->get_vers_int32()<= k_vers_160){				switch(get_nd_class_id(i)){					case BEAM_SPL_id:						tau_mag=0; tau_ang=0; rho_ang=0; max_n_sum=0;						net_stream<<tau_mag<<tau_ang<<rho_ang<<max_n_sum;//write_net						break;					case POL_ROTATOR_id:						theta=0;						net_stream<<theta;//write_net						break;											case POLARIZER_id:						theta=0;						net_stream<<theta;//write_net						break;					case QBIT_ROT_id:						for(USHORT j=0; j<4; j++){							theta=0;							net_stream<<theta;//write_net						}						break;								case SG_MAGNET_id:						theta=0; phi=0;							net_stream<<theta<<phi;//write_net						empty = true;						net_stream<<empty;//write_net												//the following is never used. Retained for bookkeeping purposes						if(!empty){							for(USHORT loc = 0; loc<nd_p->get_num_of_in_nds(); loc++){								spin = 0; theta = 0; phi = 0;								net_stream<<spin<<theta<<phi;//write_net							}						}							break;				}//switch			}//old versions		}	}	}//******************************************VOID	QB_NET::read_net_stream(LStream  &  		net_stream,		//i-o	NET_STREAM_TYPE		stream_type)	//in{		//open_reco: 	//everything remains hidden until we finally call mWindow->Show() in C_DOC	//paste_reco:	//everything remains hidden until	//we finally call Refresh() in C_DOC::paste_clipping()	//undel_reco:	//everything remains hidden until	//we finally call Refresh() in C_NET_DEL_OR_CUT_ACTION::UndoSelf()	//In the case of open_reco and undel_reco, will write unto a 	//canvas without any selections. In the case of paste_reco,	//canvas may contain previous selections. Get rid of them. Want	//only new nodes and arrows selected.	if(stream_type==paste_reco)its_mview_p->unselect_all();	if(stream_type==open_reco){SignalIf_(its_num_of_nds!=0);}		USHORT		num_of_old_nds = its_num_of_nds;	USHORT 		num_of_new_nds;	net_stream>>num_of_new_nds;//read_net		Rect	sel_rect;	if(stream_type==paste_reco){		net_stream>>sel_rect;//read_net	}			Point 		center;	STRINGY  	nd_class_str;//temporary	UInt16		UInt16_nd_class_id;	STRINGY  	nd_name;	LStr255 	descriptor_pstr;	USHORT		i;	RGBColor  	color;	SInt16 		icon_dir;	NODE  * 	nd_p;	Boolean 	dont_color;	for(i= num_of_old_nds; i<num_of_old_nds + num_of_new_nds;i++){		if(its_doc_p->get_vers_int32()<= k_vers_160){			net_stream>>nd_class_str>>center>>nd_name;//read_net						if(nd_class_str=="BEAM_SPL"){				UInt16_nd_class_id = BEAM_SPL_id;			}else if(nd_class_str=="CUSTOM_ND"){				UInt16_nd_class_id = CUSTOM_ND_id;				}else if(nd_class_str=="DET_ND"){				UInt16_nd_class_id = DET_ND_id;			}else if(nd_class_str=="POL_ROTATOR"){				UInt16_nd_class_id = POL_ROTATOR_id;			}else if(nd_class_str=="POLARIZER"){				UInt16_nd_class_id = POLARIZER_id;			}else if(nd_class_str=="QBIT_ROT"){				UInt16_nd_class_id = QBIT_ROT_id;			}else if(nd_class_str=="SG_MAGNET"){				UInt16_nd_class_id = SG_MAGNET_id;			}else{				ThrowIf_(true);			}		}else{			net_stream>>UInt16_nd_class_id>>center>>nd_name;//read_net		}				if(stream_type==paste_reco)its_mview_p->translate_pt_from_sel_to_pasting_rect(center, sel_rect);		mac_add_nd((ND_CLASS_ID)UInt16_nd_class_id, center, false);		nd_p = its_nds_p_p[i];		if(stream_type!=open_reco)nd_p->select(its_mview_p);		nd_p->set_name(nd_name);		nd_name.fill_LStr255(descriptor_pstr);		nd_p->get_efield_ptr()->SetDescriptor(descriptor_pstr);		nd_p->get_efield_ptr()->UserChangedText();//resizes the frame		//versions <= 1.0.0 do not color det nodes		dont_color = stream_type==open_reco			&& its_doc_p->get_vers_int32()<=k_vers_100			&& UInt16_nd_class_id==DET_ND_id;				if(nd_p->has_color() && !dont_color){			net_stream>>color.red>>color.green>>color.blue;//read_net			nd_p->set_color(color);				}		if(nd_p->has_icon_dir()){			net_stream>>icon_dir;//read_net			nd_p->set_icon_dir(icon_dir);		}	}	USHORT 		num_of_new_ars;	net_stream>> num_of_new_ars;//read_net	C_PORT_NAME  s_port_name, d_port_name;		for(i=0; i<num_of_new_ars; i++){		net_stream>> s_port_name;//read_net		net_stream>> d_port_name;//read_net		if(stream_type==paste_reco){			s_port_name.its_nd_id  += num_of_old_nds;			d_port_name.its_nd_id  += num_of_old_nds;		}		C_ARROW  *  ar_p = mac_add_int_arrow(s_port_name, d_port_name, false);		ThrowIfNil_(ar_p);		if(stream_type!=open_reco)ar_p->select(its_mview_p);	}		chrono_sort();	its_dyn_story.set_to_default_vec(0, its_num_of_nds);		if(stream_type==open_reco){		USHORT num_of_bi_nds;		net_stream>> num_of_bi_nds;//read_net		USHORT nd1, nd2;		for(i=0;i<num_of_bi_nds;i++){			net_stream>>nd1>>nd2;//read_net		 	add_bi_nd(nd1, nd2);		}	}					USHORT 		degen;	SET  		act_sts;	STRINGY 	st_name;	for(i= num_of_old_nds; i<its_num_of_nds;i++){		net_stream>>degen>>act_sts;//read_net		set_degen_of_a_nd(i, degen);		set_act_sts_of_a_nd(i, act_sts);		for(USHORT r=0; r<degen; r++){			net_stream>> st_name;//read_net			set_state_name(i, r, st_name);		}	}		//must load all degens before load trans mats		USHORT 		max_n_sum;	SHORT		spin=1;	DOUBLE64	theta, phi, tau_mag, tau_ang, rho_ang;//store machine indep doubles	BOOLEAN 	empty, stored_tm;	VECTOR<USHORT>	tm_in_nds; //tm = trans_mat	USHORT	num_of_in_nds;	UI_MAP	map;	USHORT	min_i = (stream_type==paste_reco?num_of_old_nds:0);	for(i= min_i; i<its_num_of_nds;i++){		nd_p = its_nds_p_p[i];		stored_tm = true;		if(stream_type!=open_reco){			net_stream>>stored_tm;//read_net		}		if(stored_tm){					num_of_in_nds = nd_p->get_num_of_in_nds();			tm_in_nds.resize(0, num_of_in_nds);			map.set_to_default_map(num_of_in_nds);						//this read was not present on vers. 1.00§1			net_stream>>tm_in_nds;//read_net			//Next steps are necessary because			//the order of the in nodes assumed by the trans mat			//may not be the same as the 			//the order of the in nodes in NODE::its_in_nds.			//The next steps makes both orders the same. 			//new order: tm_in_nds			//old order: its_in_nds						for(USHORT	j=0; j<num_of_in_nds; j++){				map.its_newfo[j]= tm_in_nds.loc_of_target( nd_p->get_in_nds()[j] - min_i );			}			map.set_oldfn();			nd_p->reorder_in_nds(map, false);						//this reads the trans mat				nd_p->read_net_stream(net_stream);//read_net			if(its_doc_p->get_vers_int32()<= k_vers_160){						switch(get_nd_class_id(i)){					case BEAM_SPL_id:						net_stream>>tau_mag>>tau_ang>>rho_ang>>max_n_sum;//read_net						break;					case POL_ROTATOR_id:						net_stream>>theta;//read_net										break;					case POLARIZER_id:						net_stream>>theta;//read_net										break;					case QBIT_ROT_id:						for(USHORT j=0; j<4; j++){							net_stream>>theta;//read_net						}						break;					case SG_MAGNET_id:						net_stream>>theta>>phi;//read_net												net_stream>>empty;//read_net												if(!empty){							for(USHORT loc = 0; loc<nd_p->get_num_of_in_nds(); loc++){								net_stream>>spin>>theta>>phi;//read_net									}						}						break;					}//switch			}//old versions		}	}}#pragma mark --export to TEXT files--		//******************************************VOID	QB_NET::write_topology_file(MY_OFSTREAM  & 	strm)		//i-o{		strm<<"//number of nodes:"<<my_endline;	strm<<its_num_of_nds<< my_endline;		strm<<"//for each node: nd_id, name, type:"<<my_endline;	NODE  * 	nd_p;	for(USHORT nd_id=0; nd_id<its_num_of_nds; nd_id++){		nd_p = its_nds_p_p[nd_id];		strm	<<nd_id				<<"  \t"				<<setw(31)				<<nd_p->get_name()				<<"  \t"				<<get_nd_class_str(nd_id)				<< my_endline;	}		strm<<"//number of internal arrows:"<<my_endline;	strm<<its_arrows.get_len()<< my_endline;	strm<<"//for each internal arrow, its source and destination nodes:"<<my_endline;	C_ARROW  *  ar_p;		DIR_DATA<C_ARROW>  *  dir_arrow_p = get_arrows_first_p();	while(dir_arrow_p){		ar_p = &(dir_arrow_p->its_data);		strm	<<ar_p->get_s_port_name().its_nd_id				<<"  \t"				<<ar_p->get_d_port_name().its_nd_id				<< my_endline;		dir_arrow_p = dir_arrow_p->its_next_p;	}	strm<<"//number of bi-nodes of interest:"<<my_endline;	strm<<its_bi_nds.get_len()<< my_endline;		strm<<"//for each of these bi-nodes, the two nodes involved:"<<my_endline;	BI_NODE  * 	bi_nd_p;	DIR_DATA<BI_NODE>  *  dir_bi_nd_p = its_bi_nds.get_first_p();	while(dir_bi_nd_p!=0){		bi_nd_p = &(dir_bi_nd_p->its_data);		strm	<<bi_nd_p->get_nd1()				<<"  \t"				<<bi_nd_p->get_nd2()				<< my_endline;		dir_bi_nd_p = dir_bi_nd_p->its_next_p;	}	strm<<"//for each node, the position (v, h) of its center:"<<my_endline;	for(USHORT nd_id=0; nd_id<its_num_of_nds; nd_id++){		nd_p = its_nds_p_p[nd_id];		strm	<<nd_id				<<"  \t"				<<setw(8)				<<nd_p->get_center().v				<<"  \t"				<<setw(8)				<<nd_p->get_center().h				<< my_endline;	}	strm<<"//for each node, its color (R, G, B):"<<my_endline;	for(USHORT nd_id=0; nd_id<its_num_of_nds; nd_id++){		nd_p = its_nds_p_p[nd_id];		strm	<<nd_id				<<"  \t"				<<setw(8)				<<nd_p->get_color().red				<<"  \t"				<<setw(8)				<<nd_p->get_color().green				<<"  \t"				<<setw(8)				<<nd_p->get_color().blue				<< my_endline;	}}		//******************************************VOID	QB_NET::write_nd_sts_file(MY_OFSTREAM  & 	strm)		//i-o{	USHORT		num = its_mview_p->get_num_of_sel_nds();	Boolean 	do_all = (num==0||num==its_num_of_nds);	for(USHORT nd_id=0; nd_id<its_num_of_nds; nd_id++){		NODE  * nd_p = its_nds_p_p[nd_id];		if( do_all || nd_p->is_selected()){			strm<<'#'<<my_endline;			strm	<<setw(31)					<<nd_p->get_name()					<<"  \t"					<<nd_p->get_degen()					<< my_endline;			for(USHORT st=0; st<nd_p->get_degen(); st++){				strm<<nd_p->get_st_name(st)<< my_endline;			}		}	}			}//******************************************VOID	QB_NET::write_amps_file(MY_OFSTREAM  & strm)		//i-o{	strm<<setprecision(6)<<setiosflags( ios::showpoint | ios::fixed );	USHORT		num = its_mview_p->get_num_of_sel_nds();	Boolean 	do_all = (num==0||num==its_num_of_nds);		for(USHORT nd_id=0; nd_id<its_num_of_nds; nd_id++){		NODE  * nd_p = its_nds_p_p[nd_id];		if( do_all || nd_p->is_selected()){			strm<<'#'<<my_endline;			strm<<nd_p->get_name()<< my_endline;			for(TM_COL_NUM in_st=0; in_st<nd_p->get_num_of_in_sts(); in_st++){				for(USHORT r=0; r<nd_p->get_num_of_in_nds(); r++){					NODE  *   in_nd_p = its_nds_p_p[nd_p->get_in_nds()[r]];					strm	<<setw(31)							<<in_nd_p->get_name()							<<"  \t"							<<setw(31)							<<in_nd_p->get_st_name( nd_p->get_in_nd_sof().vec_label(in_st)[r] )							<< my_endline;									}						for(USHORT nd_st=0; nd_st<nd_p->get_degen(); nd_st++){					COMPLEX z = nd_p->get_tm_amps().read_ele(nd_st, in_st);					strm	<<setw(31)							<<nd_p->get_st_name(nd_st)							<<"  \t"							<<real(z)							<<"  \t"							<<imag(z)							<< my_endline;							}			}		}	}			}#endif //_mac_gui_app \\............................................//